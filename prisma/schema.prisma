generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
}

model User {
  id            String            @id @default(cuid())
  address       String?           @unique
  username      String?
  name          String?
  image         String?
  emailVerified Boolean?          @default(false)
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  achievements  String[]          @default([])
  avatarUrl     String?
  description   String?
  discord       String?
  isAdmin       Boolean           @default(false)
  isBanned      Boolean           @default(false)
  telegram      String?
  twitter       String?
  website       String?
  email         String?           @unique
  password      String?
  bets          Bet[]
  createdEvents Event[]
  messages      Message[]
  reactions     MessageReaction[]
  notifications Notification[]
  transactions  Transaction[]
  orders        Order[]
  balances      Balance[]
  accounts      Account[]
  sessions      Session[]

  @@index([address])
}

model Event {
  id                 String                   @id @default(cuid())
  title              String
  description        String
  categories         String[]                 @default([])
  imageUrl           String?
  resolutionDate     DateTime
  status             String                   @default("ACTIVE")
  result             String?                  // ID of winning outcome (for multiple) or "YES"/"NO" (for binary)
  creatorId          String
  createdAt          DateTime                 @default(now())
  updatedAt          DateTime                 @updatedAt
  initialLiquidity   Float                    @default(100.0)
  isHidden           Boolean                  @default(false)
  liquidityParameter Float                    @default(10000.0) // Increased default for better AMM
  type               String                   @default("BINARY") // "BINARY" or "MULTIPLE"
  // Legacy binary fields (still used for backward compatibility)
  noOdds             Float?
  qNo                Float                    @default(0.0)
  qYes               Float                    @default(0.0)
  rules              String?
  yesOdds            Float?
  searchVector       Unsupported("tsvector")?
  outcomes           Outcome[]
  bets               Bet[]
  orders             Order[]
  trades             Trade[]
  creator            User                     @relation(fields: [creatorId], references: [id])

  @@index([status, createdAt])
  @@index([categories], type: Gin)
  @@index([creatorId])
  @@index([searchVector], type: Gin)
}

model Outcome {
  id          String   @id @default(cuid())
  eventId     String
  name        String   // e.g., "Apple", "Nvidia", "YES", "NO"
  probability Float    @default(0.0) // Current market probability (0-1)
  liquidity   Float    @default(0.0) // q value for LMSR
  color       String?  // Hex color for UI display
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  event       Event    @relation(fields: [eventId], references: [id])
  orders      Order[]
  trades      Trade[]

  @@index([eventId])
  @@unique([eventId, name])
}

model Bet {
  id           String   @id @default(cuid())
  amount       Float
  option       String
  userId       String
  eventId      String
  createdAt    DateTime @default(now())
  priceAtTrade Float?
  event        Event    @relation(fields: [eventId], references: [id])
  user         User     @relation(fields: [userId], references: [id])

  @@index([eventId])
  @@index([userId])
  @@index([createdAt])
}

model Transaction {
  id        String   @id @default(cuid())
  hash      String   @unique
  type      String
  amount    Float
  status    String
  userId    String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model Message {
  id        String            @id @default(cuid())
  text      String
  userId    String
  eventId   String
  createdAt DateTime          @default(now())
  editedAt  DateTime?
  isDeleted Boolean           @default(false)
  parentId  String?
  parent    Message?          @relation("Thread", fields: [parentId], references: [id])
  replies   Message[]         @relation("Thread")
  user      User              @relation(fields: [userId], references: [id])
  reactions MessageReaction[]

  @@index([eventId, createdAt])
  @@index([userId])
  @@index([parentId])
}

model MessageReaction {
  id        String   @id @default(cuid())
  type      String
  userId    String
  messageId String
  createdAt DateTime @default(now())
  message   Message  @relation(fields: [messageId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, messageId])
}

model Notification {
  id         String   @id @default(cuid())
  type       String
  message    String
  resourceId String?
  isRead     Boolean  @default(false)
  userId     String
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id])
}

// Order Book Models for Hybrid AMM + Orderbook System
model Order {
  id            String    @id @default(cuid())
  userId        String
  eventId       String
  outcomeId     String?   // Reference to specific outcome (for multiple outcomes)
  option        String?   // Legacy field for binary events: 'YES' or 'NO'
  side          String    // 'buy' or 'sell'
  price         Float     // Price per token (0.01 to 0.99)
  amount        Float     // Total amount to spend
  amountFilled  Float     @default(0.0) // Amount that has been filled
  status        String    @default("open") // 'open', 'partially_filled', 'filled', 'cancelled'
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  user          User      @relation(fields: [userId], references: [id])
  event         Event     @relation(fields: [eventId], references: [id])
  outcome       Outcome?  @relation(fields: [outcomeId], references: [id])
  trades        Trade[]

  @@index([eventId, side])
  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

model Trade {
  id               String    @id @default(cuid())
  eventId          String
  orderId          String    // Taker order ID
  makerOrderId     String?   // Maker order ID (if matched against another order)
  makerUserId      String?   // Maker user ID (if matched against AMM bot or user)
  outcomeId        String?   // Reference to specific outcome (for multiple outcomes)
  option           String?   // Legacy field for binary events: 'YES' or 'NO'
  side             String    // 'buy' or 'sell' from taker perspective
  price            Float     // Execution price
  amount           Float     // Amount traded
  isAmmTrade       Boolean   @default(false) // True if traded against AMM bot
  createdAt        DateTime  @default(now())

  event            Event     @relation(fields: [eventId], references: [id])
  order            Order     @relation(fields: [orderId], references: [id])
  outcome          Outcome?  @relation(fields: [outcomeId], references: [id])

  @@index([eventId])
  @@index([createdAt])
}

model Balance {
   id           String   @id @default(cuid())
   userId       String
   tokenSymbol  String   // 'TUSD' for base currency, '{outcomeId}' for outcome tokens
   eventId      String?  // NULL for base currency, event ID for outcome tokens
   outcomeId    String?  // NULL for base currency, outcome ID for outcome tokens
   amount       Float    @default(0.0)
   updatedAt    DateTime @updatedAt

   user         User     @relation(fields: [userId], references: [id])

   @@unique([userId, tokenSymbol, eventId, outcomeId])
   @@index([userId])
}

// Better Auth models
model Account {
   id                String  @id @default(cuid())
   accountId         String
   providerId        String
   userId            String
   user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

   accessToken       String?
   refreshToken      String?
   idToken           String?
   accessTokenExpiresAt DateTime?
   refreshTokenExpiresAt DateTime?
   scope             String?
   password          String?
   createdAt         DateTime @default(now())
   updatedAt         DateTime @updatedAt

   @@unique([accountId, providerId])
   @@index([userId])
}

model Session {
   id        String   @id @default(cuid())
   expiresAt DateTime
   token     String   @unique
   createdAt DateTime @default(now())
   updatedAt DateTime @updatedAt
   ipAddress String?
   userAgent String?
   userId    String
   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

   @@index([userId])
   @@index([token])
}

model Verification {
   id         String   @id @default(cuid())
   identifier String
   value      String
   expiresAt  DateTime
   createdAt  DateTime @default(now())
   updatedAt  DateTime @updatedAt
}

