
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
}

model User {
  id                   String                @id @default(cuid())
  address              String?               @unique
  username             String?
  name                 String?
  image                String?
  emailVerified        Boolean?              @default(false)
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  achievements         String[]              @default([])
  avatarUrl            String?
  description          String?
  discord              String?
  isAdmin              Boolean               @default(false)
  isBanned             Boolean               @default(false)
  isDeleted            Boolean               @default(false)
  twoFactorEnabled     Boolean?              @default(false)
  telegram             String?
  twitter              String?
  website              String?
  email                String?               @unique
  password             String?
  settings             Json? // User preferences (trading, notifications, display, privacy)
  lastIp               String?
  lastCountry          String?
  lastRegion           String?
  lastCity             String?
  lastTimezone         String?
  lastAsn              Int?
  lastIsp              String?
  lastUserAgent        String?
  lastDevice           String?
  lastOs               String?
  lastLocale           String?
  lastReferrer         String?
  lastUtmSource        String?
  lastUtmMedium        String?
  lastUtmCampaign      String?
  lastUtmTerm          String?
  lastUtmContent       String?
  lastDeviceMemory     Float?
  lastDpr              Float?
  lastViewportWidth    Int?
  lastDownlink         Float?
  lastRtt              Int?
  lastEct              String?
  lastVisitedAt        DateTime?
  currentBalance       Decimal               @default(0.0)
  totalDeposited       Decimal               @default(0.0)
  totalWithdrawn       Decimal               @default(0.0)
  telemetry            Json?
  marketActivity       MarketActivity[]
  createdEvents        Event[]
  messages             Message[]
  reactions            MessageReaction[]
  notifications        Notification[]
  transactions         Transaction[]
  orders               Order[]
  balances             Balance[]
  accounts             Account[]
  sessions             Session[]
  depositAddresses     DepositAddress[]
  deposits             Deposit[]
  withdrawals          Withdrawal[]
  favorites            UserFavorite[]
  institutionalAccount InstitutionalAccount?
  batchOrders          BatchOrder[]
  ledgerEntries        LedgerEntry[]
  eventSuggestions     EventSuggestion[]
  telemetryEvents      TelemetryEvent[]
  hedgeRecords         HedgeRecord[]

  // Support System Relations
  supportRole         String? // null | "agent" | "admin" | "support_manager"
  ticketsCreated      SupportTicket[]     @relation("TicketUser")
  ticketsAssigned     SupportTicket[]     @relation("TicketAgent")
  passkeys            Passkey[]
  supportMessages     SupportMessage[]    @relation("SupportMessageUser")
  supportNotes        SupportNote[]       @relation("NoteAgent")
  attachmentsUploaded SupportAttachment[] @relation("AttachmentUploader")
  auditLogs           SupportAuditLog[]   @relation("AuditUser")
  telegramLink        TelegramUser?       @relation("LinkedTelegramUser")

  // Affiliate referral tracking
  referredBy     String? // Affiliate ID who referred this user
  referralDate   DateTime? // When user clicked affiliate link
  referralRecord Referral?

  twofactors TwoFactor[]

  @@index([address])
  @@index([lastVisitedAt])
  @@index([lastCountry])
  @@index([lastCity])
  @@index([lastRegion])
  @@index([supportRole])
  @@index([referredBy])
  @@map("user")
}

model TelemetryEvent {
  id        String   @id @default(cuid())
  userId    String
  type      String // perf | error | feature | security
  name      String // event name/key
  payload   Json?
  ip        String?
  userAgent String?
  country   String?
  city      String?
  region    String?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([type, createdAt])
}

model Event {
  id                 String                   @id @default(cuid())
  title              String
  description        String
  categories         String[]                 @default([])
  imageUrl           String?
  resolutionDate     DateTime
  status             String                   @default("ACTIVE")
  result             String? // ID of winning outcome (for multiple) or "YES"/"NO" (for binary)
  creatorId          String
  createdAt          DateTime                 @default(now())
  updatedAt          DateTime                 @updatedAt
  initialLiquidity   Float                    @default(100.0)
  isHidden           Boolean                  @default(false)
  liquidityParameter Float                    @default(20000.0) // Higher for stability with low users
  type               String                   @default("BINARY") // "BINARY" or "MULTIPLE"
  source             String                   @default("LOCAL") // LOCAL | POLYMARKET | OTHER
  polymarketId       String?                  @unique
  resolutionSource   String? // e.g. POLYMARKET, MANUAL
  resolvedAt         DateTime?
  externalVolume     Float?                   @default(0.0) // Upstream market volume (e.g., Polymarket)
  externalBetCount   Int?                     @default(0)
  // Legacy binary fields (still used for backward compatibility)
  noOdds             Float?
  qNo                Float                    @default(0.0)
  qYes               Float                    @default(0.0)
  rules              String?
  yesOdds            Float?
  searchVector       Unsupported("tsvector")?
  outcomes           Outcome[]
  marketActivity     MarketActivity[]
  orders             Order[]
  favorites          UserFavorite[]
  creator            User                     @relation(fields: [creatorId], references: [id])
  polyOrders         PolyOrder[]              @relation("PolyOrderEvent")
  polyPositions      PolyPosition[]           @relation("PolyPositionEvent")
  oddsHistory        OddsHistory[]
  polymarketMapping  PolymarketMarketMapping? @relation("PolymarketMapping")
  hedgeRecords       HedgeRecord[]

  // Sports-specific metadata
  league     String? // "NFL", "NBA", "CSGO", "Dota 2"
  sport      String? // "football", "basketball", "esports"
  teamA      String? // Team/player name
  teamB      String? // Opponent team/player name
  teamALogo  String? // Team logo URL
  teamBLogo  String? // Team logo URL
  score      String? // "24-17", "3-2"
  period     String? // "Q3", "2nd Half", "Map 2"
  elapsed    String? // "12:34", "45:00"
  live       Boolean   @default(false)
  gameStatus String? // "scheduled", "live", "finished", "postponed"
  startTime  DateTime? // Actual game start time
  isEsports  Boolean   @default(false)
  eventType  String?   @default("upcoming") // 'live' | 'upcoming' | 'futures'

  // Fast queries for live/upcoming
  // Fast esports filtering
  // Fast queries by event type
  // Fast sorting by event type and start time
  @@index([status, createdAt])
  @@index([categories], type: Gin)
  @@index([creatorId])
  @@index([searchVector], type: Gin)
  @@index([live, startTime])
  @@index([isEsports, live])
  @@index([eventType, live])
  @@index([eventType, startTime])
}

model EventSuggestion {
  id              String    @id @default(cuid())
  userId          String
  title           String
  description     String
  categories      String[]  @default([])
  imageUrl        String?
  resolutionDate  DateTime
  type            String    @default("BINARY") // 'BINARY' or 'MULTIPLE'
  outcomes        Json?
  status          String    @default("PENDING") // 'PENDING' | 'APPROVED' | 'DECLINED'
  reviewedBy      String?
  reviewedAt      DateTime?
  reviewNote      String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  approvedEventId String?

  user User @relation(fields: [userId], references: [id])

  @@index([status, createdAt])
  @@index([userId])
}

model Outcome {
  id                  String   @id @default(cuid())
  eventId             String
  name                String // e.g., "Apple", "Nvidia", "YES", "NO"
  probability         Float    @default(0.0) // Current market probability (0-1)
  liquidity           Float    @default(0.0) // q value for LMSR
  color               String? // Hex color for UI display
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  polymarketMarketId  String?
  polymarketOutcomeId String?  @unique
  source              String? // LOCAL | POLYMARKET | OTHER

  event          Event            @relation(fields: [eventId], references: [id])
  orders         Order[]
  marketActivity MarketActivity[]
  polyOrders     PolyOrder[]      @relation("PolyOrderOutcome")
  polyPositions  PolyPosition[]   @relation("PolyPositionOutcome")
  oddsHistory    OddsHistory[]

  @@unique([eventId, name])
  @@index([eventId])
  @@index([polymarketOutcomeId])
}

model OddsHistory {
  id                String   @default(cuid())
  eventId           String
  outcomeId         String
  polymarketTokenId String?
  timestamp         DateTime
  price             Float
  probability       Float
  source            String   @default("POLYMARKET")
  createdAt         DateTime @default(now())

  event   Event   @relation(fields: [eventId], references: [id])
  outcome Outcome @relation(fields: [outcomeId], references: [id])

  @@id([id, timestamp])
  @@unique([eventId, outcomeId, timestamp])
}

model MarketActivity {
  id               String   @id @default(cuid())
  type             String // 'BET' | 'TRADE' | 'ORDER_FILL'
  userId           String
  eventId          String
  outcomeId        String? // For multiple outcomes
  option           String? // For binary events
  side             String? // For trades
  amount           Decimal
  price            Decimal?
  isAmmInteraction Boolean
  orderId          String? // Related order
  createdAt        DateTime @default(now())

  user    User     @relation(fields: [userId], references: [id])
  event   Event    @relation(fields: [eventId], references: [id])
  outcome Outcome? @relation(fields: [outcomeId], references: [id])
  order   Order?   @relation(fields: [orderId], references: [id])

  @@index([eventId])
  @@index([userId])
  @@index([createdAt])
  @@index([orderId])
}

model Transaction {
  id        String   @id @default(cuid())
  hash      String   @unique
  type      String
  amount    Decimal
  status    String
  userId    String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model Message {
  id        String            @id @default(cuid())
  text      String
  userId    String
  eventId   String
  createdAt DateTime          @default(now())
  editedAt  DateTime?
  isDeleted Boolean           @default(false)
  parentId  String?
  parent    Message?          @relation("Thread", fields: [parentId], references: [id])
  replies   Message[]         @relation("Thread")
  user      User              @relation(fields: [userId], references: [id])
  reactions MessageReaction[]

  @@index([eventId, createdAt])
  @@index([userId])
  @@index([parentId])
}

model MessageReaction {
  id        String   @id @default(cuid())
  type      String
  userId    String
  messageId String
  createdAt DateTime @default(now())
  message   Message  @relation(fields: [messageId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, messageId])
}

model Notification {
  id         String   @id @default(cuid())
  type       String
  message    String
  resourceId String?
  isRead     Boolean  @default(false)
  userId     String
  createdAt  DateTime @default(now())
  metadata   Json? // Rich context: {eventTitle, amount, price, outcome, side, etc.}
  user       User     @relation(fields: [userId], references: [id])

  @@index([userId, isRead])
  @@index([createdAt])
}

model Order {
  id             String   @id @default(cuid())
  userId         String
  eventId        String
  outcomeId      String? // Reference to specific outcome (for multiple outcomes)
  option         String? // Legacy field for binary events: 'YES' or 'NO'
  side           String // 'buy' or 'sell'
  price          Decimal // Price per token (0.01 to 0.99)
  amount         Decimal // Total amount to spend
  amountFilled   Decimal  @default(0.0) // Amount that has been filled
  status         String   @default("open") // 'open', 'partially_filled', 'filled', 'cancelled'
  orderType      String   @default("limit") // 'market', 'limit', 'iceberg', 'twap', 'stop'
  // Advanced order fields
  visibleAmount  Decimal? // For iceberg orders: visible portion
  totalAmount    Decimal? // For iceberg orders: total amount
  timeWindow     Int? // For TWAP: time window in minutes
  totalDuration  Int? // For TWAP: total duration in minutes
  executedSlices Int      @default(0) // For TWAP: number of executed slices
  stopPrice      Decimal? // For stop orders: trigger price
  stopType       String? // For stop orders: 'stop_loss', 'stop_limit'
  batchId        String? // Reference to batch operation
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user           User             @relation(fields: [userId], references: [id])
  event          Event            @relation(fields: [eventId], references: [id])
  outcome        Outcome?         @relation(fields: [outcomeId], references: [id])
  marketActivity MarketActivity[]
  executions     OrderExecution[]
  batch          BatchOrder?      @relation(fields: [batchId], references: [id])
  hedgePosition  HedgePosition?
  polyOrder      PolyOrder?       @relation("PolyOrderOrder")
  hedgeRecord    HedgeRecord?

  @@index([eventId, side])
  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@index([batchId])
}

model BatchOrder {
  id               String   @id @default(cuid())
  userId           String
  idempotencyKey   String   @unique // For bulk operation idempotency
  status           String   @default("processing") // 'processing', 'completed', 'failed'
  totalOrders      Int      @default(0)
  successfulOrders Int      @default(0)
  failedOrders     Int      @default(0)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user   User    @relation(fields: [userId], references: [id])
  orders Order[]

  @@index([userId])
  @@index([idempotencyKey])
  @@index([status])
}

model OrderExecution {
  id         String   @id @default(cuid())
  orderId    String
  amount     Decimal // Amount filled in this execution
  price      Decimal // Execution price
  executedAt DateTime @default(now())

  order Order @relation(fields: [orderId], references: [id])

  @@index([orderId])
  @@index([executedAt])
}

model Balance {
  id          String   @id @default(cuid())
  userId      String
  tokenSymbol String // 'TUSD' for base currency, '{outcomeId}' for outcome tokens
  eventId     String? // NULL for base currency, event ID for outcome tokens
  outcomeId   String? // NULL for base currency, outcome ID for outcome tokens
  amount      Decimal  @default(0.0)
  locked      Decimal  @default(0.0)
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@unique([userId, tokenSymbol, eventId, outcomeId])
  @@index([userId])
}

model LedgerEntry {
  id            String   @id @default(cuid())
  userId        String
  direction     String // 'CREDIT' | 'DEBIT'
  amount        Decimal
  currency      String // e.g., 'TUSD'
  balanceBefore Decimal
  balanceAfter  Decimal
  referenceType String? // 'DEPOSIT' | 'WITHDRAWAL' | 'TRADE' | etc.
  referenceId   String?
  metadata      Json?
  createdAt     DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([referenceType, referenceId])
}

// Better Auth models

model Account {
  id         String @id @default(cuid())
  accountId  String
  providerId String
  userId     String
  user       User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@unique([accountId, providerId])
  @@index([userId])
  @@map("account")
}

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("session")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

model TwoFactor {
  id          String   @id @default(cuid())
  userId      String   @unique
  secret      String
  backupCodes String // better-auth stores as encrypted string
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([secret])
  @@index([userId])
  @@map("twoFactor")
}

model Passkey {
  id           String   @id @default(cuid())
  name         String?
  publicKey    String
  userId       String
  credentialID String
  counter      Int
  deviceType   String
  backedUp     Boolean
  transports   String?
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  aaguid String?

  @@index([userId])
  @@index([credentialID])
  @@map("passkey")
}

model DepositAddress {
  id              String   @id @default(cuid())
  userId          String
  address         String   @unique
  currency        String // "ETH", "USDT", etc.
  derivationIndex Int // HD wallet index
  createdAt       DateTime @default(now())
  user            User     @relation(fields: [userId], references: [id])

  @@unique([userId, currency])
  @@index([address])
}

model Deposit {
  id          String   @id @default(cuid())
  userId      String
  amount      Decimal
  currency    String
  txHash      String   @unique
  status      String // "PENDING", "PENDING_SWEEP", "COMPLETED", "FAILED"
  fromAddress String
  toAddress   String
  retryCount  Int?     @default(0) // Track sweep retries
  metadata    Json? // Store error logs, retry schedules, etc.
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id])

  // Index for efficient PENDING_SWEEP queries
  @@index([userId])
  @@index([txHash])
  @@index([status])
}

model Withdrawal {
  id             String    @id @default(cuid())
  userId         String
  amount         Decimal
  currency       String
  toAddress      String
  txHash         String?
  idempotencyKey String?   @unique
  status         String // "PENDING", "APPROVED", "REJECTED", "COMPLETED", "FAILED"
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  approvedAt     DateTime?
  approvedBy     String? // Admin ID
  user           User      @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([status])
}

model UserFavorite {
  id        String   @id @default(cuid())
  userId    String
  eventId   String
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id])
  event Event @relation(fields: [eventId], references: [id])

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
}

model InstitutionalAccount {
  id              String    @id @default(cuid())
  userId          String    @unique
  name            String
  type            String // e.g., "LIQUIDITY_PROVIDER", "MARKET_MAKER"
  maxOrderSize    Decimal   @default(10000.0)
  maxDailyVolume  Decimal   @default(100000.0)
  dailyVolume     Decimal   @default(0.0) // Current day's volume
  dailyVolumeDate DateTime? // Date when dailyVolume was last reset
  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  user    User     @relation(fields: [userId], references: [id])
  apiKeys ApiKey[]

  @@index([userId])
}

model ApiKey {
  id          String    @id @default(cuid())
  accountId   String
  key         String    @unique
  secret      String // hashed
  permissions String[]  @default([]) // e.g., ["trade", "read", "admin"]
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastUsedAt  DateTime?

  account InstitutionalAccount @relation(fields: [accountId], references: [id])

  @@index([key])
  @@index([accountId])
}

// Hedging and Risk Management Models

model HedgePosition {
  id                 String    @id @default(cuid())
  userOrderId        String?   @unique
  polymarketOrderId  String?
  polymarketMarketId String
  side               String // 'buy' or 'sell' on Polymarket
  amount             Decimal // Number of shares/contracts
  userPrice          Decimal // Price user got on our platform
  hedgePrice         Decimal // Price we got on Polymarket
  spreadCaptured     Decimal // Our profit: abs(userPrice - hedgePrice)
  status             String // 'pending', 'hedged', 'partial', 'failed', 'closed'
  failureReason      String? // If hedge failed, why?
  hedgedAt           DateTime?
  closedAt           DateTime?
  polymarketFees     Decimal   @default(0.0)
  gasCost            Decimal   @default(0.0)
  netProfit          Decimal   @default(0.0) // spreadCaptured - fees - gas
  retryCount         Int       @default(0)
  metadata           Json? // Additional data (slippage, liquidity snapshot, etc.)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  userOrder Order? @relation(fields: [userOrderId], references: [id])

  @@index([status])
  @@index([createdAt])
  @@index([polymarketMarketId])
  @@index([hedgedAt])
}

model PolymarketMarketMapping {
  id                    String    @id @default(cuid())
  internalEventId       String    @unique
  polymarketId          String // Polymarket event/market ID
  polymarketConditionId String? // CLOB condition ID for trading
  polymarketTokenId     String? // Token contract address (legacy)
  yesTokenId            String? // YES outcome token ID for CLOB API
  noTokenId             String? // NO outcome token ID for CLOB API
  outcomeMapping        Json? // Map our outcome IDs to Polymarket outcome IDs
  isActive              Boolean   @default(true)
  lastSyncedAt          DateTime?
  liquiditySnapshot     Json? // Recent liquidity data
  status                String    @default("approved") // approved | rejected
  updatedBy             String?
  decisionAt            DateTime?
  notes                 String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  event Event @relation("PolymarketMapping", fields: [internalEventId], references: [id])

  @@index([polymarketId])
  @@index([internalEventId])
}

model PolyOrder {
  id                  String    @id @default(cuid())
  userOrderId         String    @unique
  eventId             String
  outcomeId           String?
  polymarketOrderId   String?
  polymarketMarketId  String
  polymarketOutcomeId String?
  side                String // buy | sell
  price               Decimal
  amount              Decimal
  amountFilled        Decimal   @default(0.0)
  status              String    @default("pending") // pending | placed | filled | partial | cancelled | failed
  error               String?
  placedAt            DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  userOrder Order    @relation("PolyOrderOrder", fields: [userOrderId], references: [id])
  event     Event    @relation("PolyOrderEvent", fields: [eventId], references: [id])
  outcome   Outcome? @relation("PolyOrderOutcome", fields: [outcomeId], references: [id])

  @@index([status])
  @@index([polymarketMarketId])
  @@index([polymarketOutcomeId])
  @@index([eventId])
}

model PolyPosition {
  id                  String    @id @default(cuid())
  eventId             String
  outcomeId           String?
  polymarketMarketId  String
  polymarketOutcomeId String?
  netExposure         Decimal   @default(0.0) // User-side exposure
  hedgedExposure      Decimal   @default(0.0) // How much we've hedged on Polymarket
  lastHedgeAt         DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  event   Event    @relation("PolyPositionEvent", fields: [eventId], references: [id])
  outcome Outcome? @relation("PolyPositionOutcome", fields: [outcomeId], references: [id])

  @@unique([eventId, outcomeId])
  @@index([polymarketMarketId])
  @@index([polymarketOutcomeId])
}

model PolySyncCursor {
  id                  String    @id @default(cuid())
  lastMarketUpdatedAt DateTime?
  lastCursor          String?
  lastRunAt           DateTime?
  note                String?
}

model RiskSnapshot {
  id                  String   @id @default(cuid())
  timestamp           DateTime @default(now())
  totalUnhedgedValue  Decimal // Total USD value of unhedged positions
  totalHedgedValue    Decimal // Total USD value of hedged positions
  netExposure         Decimal // Net directional exposure
  totalSpreadCaptured Decimal // Cumulative profit from spreads
  hedgeSuccessRate    Decimal // % of successful hedges
  averageHedgeTime    Int? // Average time to hedge in milliseconds
  openPositionsCount  Int // Number of open unhedged positions
  failedHedgesCount   Int // Number of failed hedges in period
  marketExposure      Json // Per-market exposure breakdown

  @@index([timestamp])
}

model HedgeConfig {
  id          String   @id @default(cuid())
  key         String   @unique // Config key
  value       Json // Config value (can be number, string, object, etc.)
  description String?
  updatedAt   DateTime @updatedAt
  updatedBy   String? // Admin user who updated

  @@index([key])
}

// New simplified hedge tracking (replaces PolyOrder + PolyPosition + HedgePosition)

model HedgeRecord {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // User trade info
  userId      String
  userOrderId String @unique
  eventId     String
  option      String // YES/NO
  userAmount  Float // What user paid ($)
  userPrice   Float // Price user got (0-1)

  // Polymarket hedge info
  polymarketOrderId  String?
  polymarketMarketId String
  polymarketTokenId  String
  polymarketSide     String // BUY/SELL
  polymarketAmount   Float // Shares hedged
  polymarketPrice    Float // PM fill price
  polymarketFees     Float // Estimated fees

  // Economics
  ourSpread Float // Markup we added
  netProfit Float // Spread - fees

  // Status
  status String // pending, hedged, failed
  error  String?

  // Relations
  user  User  @relation(fields: [userId], references: [id])
  order Order @relation(fields: [userOrderId], references: [id])
  event Event @relation(fields: [eventId], references: [id])

  @@index([userId])
  @@index([eventId])
  @@index([status])
  @@index([createdAt])
}

// ============================================
// SUPPORT TICKETING SYSTEM
// ============================================

// Support Ticket

model SupportTicket {
  id           String  @id @default(cuid())
  ticketNumber String  @unique // Human-readable: TICK-2024-0001
  userId       String
  assignedToId String? // Support agent

  // Ticket metadata
  status   String @default("open") // open | pending | resolved | closed
  priority String @default("medium") // low | medium | high | critical
  category String // deposit | withdrawal | dispute | bug | kyc | general
  subject  String

  // Source tracking
  source         String // web | telegram
  telegramChatId String? // If created via Telegram

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  firstResponseAt DateTime? // SLA tracking
  resolvedAt      DateTime?
  closedAt        DateTime?

  // Relations
  user        User                @relation("TicketUser", fields: [userId], references: [id])
  assignedTo  User?               @relation("TicketAgent", fields: [assignedToId], references: [id])
  messages    SupportMessage[]
  attachments SupportAttachment[]
  notes       SupportNote[]
  auditLogs   SupportAuditLog[]

  @@index([userId])
  @@index([assignedToId])
  @@index([status])
  @@index([priority])
  @@index([category])
  @@index([source])
  @@index([createdAt])
  @@index([telegramChatId])
}

// Support Messages (immutable)

model SupportMessage {
  id         String   @id @default(cuid())
  ticketId   String
  userId     String
  content    String   @db.Text
  isInternal Boolean  @default(false) // False = visible to user
  createdAt  DateTime @default(now())

  // Message metadata
  source            String // web | telegram | agent
  telegramMessageId Int? // For Telegram sync

  // Relations
  ticket      SupportTicket       @relation(fields: [ticketId], references: [id])
  user        User                @relation("SupportMessageUser", fields: [userId], references: [id])
  attachments SupportAttachment[]

  @@index([ticketId, createdAt])
  @@index([userId])
}

// File Attachments

model SupportAttachment {
  id        String  @id @default(cuid())
  ticketId  String
  messageId String? // Optional: can be attached to ticket or message

  // File metadata
  fileName String
  fileSize Int // bytes
  mimeType String
  url      String // Vercel Blob URL

  // Security
  uploadedBy String
  uploadedAt DateTime @default(now())
  isScanned  Boolean  @default(false)
  scanStatus String? // clean | malware | error

  // Relations
  ticket   SupportTicket   @relation(fields: [ticketId], references: [id])
  message  SupportMessage? @relation(fields: [messageId], references: [id])
  uploader User            @relation("AttachmentUploader", fields: [uploadedBy], references: [id])

  @@index([ticketId])
  @@index([messageId])
  @@index([uploadedBy])
}

// Internal Notes (support team only)

model SupportNote {
  id        String   @id @default(cuid())
  ticketId  String
  agentId   String
  content   String   @db.Text
  createdAt DateTime @default(now())

  ticket SupportTicket @relation(fields: [ticketId], references: [id])
  agent  User          @relation("NoteAgent", fields: [agentId], references: [id])

  @@index([ticketId, createdAt])
}

// Audit Log (immutable)

model SupportAuditLog {
  id       String @id @default(cuid())
  ticketId String
  userId   String // Who performed the action
  action   String // created | assigned | status_changed | priority_changed | etc.

  // Change tracking
  fieldName String? // What changed (status, priority, etc.)
  oldValue  String?
  newValue  String?
  metadata  Json? // Additional context

  createdAt DateTime @default(now())

  ticket SupportTicket @relation(fields: [ticketId], references: [id])
  user   User          @relation("AuditUser", fields: [userId], references: [id])

  @@index([ticketId, createdAt])
  @@index([userId])
  @@index([action])
}

// Telegram User Linking

model TelegramUser {
  id         String  @id @default(cuid())
  telegramId String  @unique // Telegram user ID
  chatId     String  @unique // Telegram chat ID
  username   String?
  firstName  String?
  lastName   String?

  // Linking status
  userId         String?   @unique // NULL = unverified temporary user
  isVerified     Boolean   @default(false)
  linkCode       String?   @unique // 6-digit code for account linking
  linkCodeExpiry DateTime? // Expiry time for link code

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  lastActiveAt DateTime @default(now())

  user User? @relation("LinkedTelegramUser", fields: [userId], references: [id])

  @@index([telegramId])
  @@index([userId])
}

// Rate Limiting

model SupportRateLimit {
  id          String   @id @default(cuid())
  userId      String
  action      String // ticket_create | message_send
  count       Int      @default(0)
  windowStart DateTime @default(now())

  @@unique([userId, action, windowStart])
  @@index([userId, action])
}

// ============================================
// AFFILIATE SYSTEM
// ============================================

model Affiliate {
  id          String  @id @default(cuid())
  email       String  @unique
  password    String // Hashed password
  name        String
  companyName String?
  website     String?

  // Tracking identifiers
  referralCode String @unique // e.g., "JOHN2024"

  // Statistics (counts only - no money amounts)
  totalReferrals  Int @default(0)
  activeReferrals Int @default(0) // Users who deposited
  totalDeposits   Int @default(0) // Count of deposits

  // Status
  isActive      Boolean @default(true)
  emailVerified Boolean @default(false)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastLoginAt DateTime?

  // Relations
  referrals  Referral[]
  promoCodes PromoCode[]

  @@index([referralCode])
  @@index([email])
  @@index([isActive])
}

model PromoCode {
  id          String  @id @default(cuid())
  affiliateId String
  code        String  @unique // e.g., "SAVE20"
  description String?

  usageCount Int  @default(0)
  maxUses    Int? // Null = unlimited

  isActive  Boolean   @default(true)
  expiresAt DateTime?
  createdAt DateTime  @default(now())

  affiliate Affiliate  @relation(fields: [affiliateId], references: [id])
  referrals Referral[]

  @@index([code])
  @@index([affiliateId])
}

model Referral {
  id          String  @id @default(cuid())
  affiliateId String
  userId      String  @unique // The referred user
  promoCodeId String? // If promo code was used

  // Tracking metadata
  referralSource String? // "URL" or "PROMO_CODE"
  utmSource      String?
  utmMedium      String?
  utmCampaign    String?
  ipAddress      String?
  userAgent      String?

  // Conversion tracking
  signupDate       DateTime  @default(now())
  firstDepositDate DateTime?

  // Counts (visible to affiliate)
  depositCount Int @default(0) // Number of deposits made

  // Revenue tracking (ADMIN ONLY - not shown to affiliate)
  totalDepositAmount Decimal @default(0.0) // Total $ deposited
  totalVolume        Decimal @default(0.0) // Total trading volume
  totalRevenue       Decimal @default(0.0) // Platform profit from this user

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  affiliate Affiliate  @relation(fields: [affiliateId], references: [id])
  user      User       @relation(fields: [userId], references: [id])
  promoCode PromoCode? @relation(fields: [promoCodeId], references: [id])

  @@unique([affiliateId, userId])
  @@index([affiliateId])
  @@index([userId])
  @@index([firstDepositDate])
}
