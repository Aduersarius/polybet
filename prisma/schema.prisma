generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
}

model User {
  id            String            @id @default(cuid())
  address       String?           @unique
  username      String?
  name          String?
  image         String?
  emailVerified Boolean?          @default(false)
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  achievements  String[]          @default([])
  avatarUrl     String?
  description   String?
  discord       String?
  isAdmin       Boolean           @default(false)
  isBanned      Boolean           @default(false)
  isDeleted     Boolean           @default(false)
  twoFactorEnabled Boolean?       @default(false)
  telegram      String?
  twitter       String?
  website       String?
  email         String?           @unique
  password      String?
  settings      Json?             // User preferences (trading, notifications, display, privacy)
  lastIp        String?
  lastCountry   String?
  lastUserAgent String?
  lastDevice    String?
  lastOs        String?
  lastVisitedAt DateTime?
  currentBalance  Decimal         @default(0.0)
  totalDeposited  Decimal         @default(0.0)
  totalWithdrawn  Decimal         @default(0.0)
  telemetry     Json?
  marketActivity MarketActivity[]
  createdEvents Event[]
  messages      Message[]
  reactions     MessageReaction[]
  notifications Notification[]
  transactions  Transaction[]
  orders        Order[]
  balances      Balance[]
  accounts      Account[]
  sessions      Session[]
  depositAddresses DepositAddress[]
  deposits         Deposit[]
  withdrawals      Withdrawal[]
  favorites        UserFavorite[]
  institutionalAccount InstitutionalAccount?
  batchOrders   BatchOrder[]
  ledgerEntries    LedgerEntry[]
  eventSuggestions EventSuggestion[]

  @@index([address])
  @@index([lastVisitedAt])
  @@index([lastCountry])
}

model Event {
  id                 String                   @id @default(cuid())
  title              String
  description        String
  categories         String[]                 @default([])
  imageUrl           String?
  resolutionDate     DateTime
  status             String                   @default("ACTIVE")
  result             String?                  // ID of winning outcome (for multiple) or "YES"/"NO" (for binary)
  creatorId          String
  createdAt          DateTime                 @default(now())
  updatedAt          DateTime                 @updatedAt
  initialLiquidity   Float                    @default(100.0)
  isHidden           Boolean                  @default(false)
  liquidityParameter Float                    @default(20000.0) // Higher for stability with low users
  type               String                   @default("BINARY") // "BINARY" or "MULTIPLE"
  // Legacy binary fields (still used for backward compatibility)
  noOdds             Float?
  qNo                Float                    @default(0.0)
  qYes               Float                    @default(0.0)
  rules              String?
  yesOdds            Float?
  searchVector       Unsupported("tsvector")?
  outcomes           Outcome[]
  marketActivity     MarketActivity[]
  orders             Order[]
  favorites          UserFavorite[]
  creator            User                     @relation(fields: [creatorId], references: [id])

  @@index([status, createdAt])
  @@index([categories], type: Gin)
  @@index([creatorId])
  @@index([searchVector], type: Gin)
}

model EventSuggestion {
  id              String   @id @default(cuid())
  userId          String
  title           String
  description     String
  categories      String[] @default([])
  imageUrl        String?
  resolutionDate  DateTime
  type            String   @default("BINARY") // 'BINARY' or 'MULTIPLE'
  outcomes        Json?
  status          String   @default("PENDING") // 'PENDING' | 'APPROVED' | 'DECLINED'
  reviewedBy      String?
  reviewedAt      DateTime?
  reviewNote      String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  approvedEventId String?

  user            User     @relation(fields: [userId], references: [id])

  @@index([status, createdAt])
  @@index([userId])
}

model Outcome {
  id          String   @id @default(cuid())
  eventId     String
  name        String   // e.g., "Apple", "Nvidia", "YES", "NO"
  probability Float    @default(0.0) // Current market probability (0-1)
  liquidity   Float    @default(0.0) // q value for LMSR
  color       String?  // Hex color for UI display
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  event       Event    @relation(fields: [eventId], references: [id])
  orders      Order[]
  marketActivity MarketActivity[]

  @@index([eventId])
  @@unique([eventId, name])
}

model MarketActivity {
  id               String    @id @default(cuid())
  type             String    // 'BET' | 'TRADE' | 'ORDER_FILL'
  userId           String
  eventId          String
  outcomeId        String?   // For multiple outcomes
  option           String?   // For binary events
  side             String?   // For trades
  amount           Float
  price            Float?
  isAmmInteraction Boolean
  orderId          String?   // Related order
  createdAt        DateTime  @default(now())

  user             User      @relation(fields: [userId], references: [id])
  event            Event     @relation(fields: [eventId], references: [id])
  outcome          Outcome?  @relation(fields: [outcomeId], references: [id])
  order            Order?    @relation(fields: [orderId], references: [id])

  @@index([eventId])
  @@index([userId])
  @@index([createdAt])
  @@index([orderId])
}

model Transaction {
  id        String   @id @default(cuid())
  hash      String   @unique
  type      String
  amount    Float
  status    String
  userId    String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model Message {
  id        String            @id @default(cuid())
  text      String
  userId    String
  eventId   String
  createdAt DateTime          @default(now())
  editedAt  DateTime?
  isDeleted Boolean           @default(false)
  parentId  String?
  parent    Message?          @relation("Thread", fields: [parentId], references: [id])
  replies   Message[]         @relation("Thread")
  user      User              @relation(fields: [userId], references: [id])
  reactions MessageReaction[]

  @@index([eventId, createdAt])
  @@index([userId])
  @@index([parentId])
}

model MessageReaction {
  id        String   @id @default(cuid())
  type      String
  userId    String
  messageId String
  createdAt DateTime @default(now())
  message   Message  @relation(fields: [messageId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, messageId])
}

model Notification {
  id         String   @id @default(cuid())
  type       String
  message    String
  resourceId String?
  isRead     Boolean  @default(false)
  userId     String
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id])
}

model Order {
   id            String    @id @default(cuid())
   userId        String
   eventId       String
   outcomeId     String?   // Reference to specific outcome (for multiple outcomes)
   option        String?   // Legacy field for binary events: 'YES' or 'NO'
   side          String    // 'buy' or 'sell'
   price         Float     // Price per token (0.01 to 0.99)
   amount        Float     // Total amount to spend
   amountFilled  Float     @default(0.0) // Amount that has been filled
   status        String    @default("open") // 'open', 'partially_filled', 'filled', 'cancelled'
   orderType     String    @default("limit") // 'market', 'limit', 'iceberg', 'twap', 'stop'
   // Advanced order fields
   visibleAmount Float?    // For iceberg orders: visible portion
   totalAmount   Float?    // For iceberg orders: total amount
   timeWindow    Int?      // For TWAP: time window in minutes
   totalDuration Int?      // For TWAP: total duration in minutes
   executedSlices Int      @default(0) // For TWAP: number of executed slices
   stopPrice     Float?    // For stop orders: trigger price
   stopType      String?   // For stop orders: 'stop_loss', 'stop_limit'
   batchId       String?   // Reference to batch operation
   createdAt     DateTime  @default(now())
   updatedAt     DateTime  @updatedAt

   user          User      @relation(fields: [userId], references: [id])
   event         Event     @relation(fields: [eventId], references: [id])
   outcome       Outcome?  @relation(fields: [outcomeId], references: [id])
   marketActivity MarketActivity[]
   executions    OrderExecution[]
   batch         BatchOrder? @relation(fields: [batchId], references: [id])

   @@index([eventId, side])
   @@index([userId])
   @@index([status])
   @@index([createdAt])
   @@index([batchId])
}

model BatchOrder {
   id            String   @id @default(cuid())
   userId        String
   idempotencyKey String  @unique // For bulk operation idempotency
   status        String   @default("processing") // 'processing', 'completed', 'failed'
   totalOrders   Int      @default(0)
   successfulOrders Int   @default(0)
   failedOrders  Int      @default(0)
   createdAt     DateTime @default(now())
   updatedAt     DateTime @updatedAt

   user          User     @relation(fields: [userId], references: [id])
   orders        Order[]

   @@index([userId])
   @@index([idempotencyKey])
   @@index([status])
}

model OrderExecution {
   id            String   @id @default(cuid())
   orderId       String
   amount        Float    // Amount filled in this execution
   price         Float    // Execution price
   executedAt    DateTime @default(now())

   order         Order    @relation(fields: [orderId], references: [id])

   @@index([orderId])
   @@index([executedAt])
}

model Balance {
   id           String   @id @default(cuid())
   userId       String
   tokenSymbol  String   // 'TUSD' for base currency, '{outcomeId}' for outcome tokens
   eventId      String?  // NULL for base currency, event ID for outcome tokens
   outcomeId    String?  // NULL for base currency, outcome ID for outcome tokens
   amount       Decimal  @default(0.0)
   locked       Decimal  @default(0.0)
   updatedAt    DateTime @updatedAt

   user         User     @relation(fields: [userId], references: [id])

   @@unique([userId, tokenSymbol, eventId, outcomeId])
   @@index([userId])
}

model LedgerEntry {
  id           String   @id @default(cuid())
  userId       String
  direction    String   // 'CREDIT' | 'DEBIT'
  amount       Decimal
  currency     String   // e.g., 'TUSD'
  balanceBefore Decimal
  balanceAfter  Decimal
  referenceType String? // 'DEPOSIT' | 'WITHDRAWAL' | 'TRADE' | etc.
  referenceId   String?
  metadata      Json?
  createdAt     DateTime @default(now())

  user         User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([referenceType, referenceId])
}

// Better Auth models
model Account {
   id                String  @id @default(cuid())
   accountId         String
   providerId        String
   userId            String
   user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

   accessToken       String?
   refreshToken      String?
   idToken           String?
   accessTokenExpiresAt DateTime?
   refreshTokenExpiresAt DateTime?
   scope             String?
   password          String?
   createdAt         DateTime @default(now())
   updatedAt         DateTime @updatedAt

   @@unique([accountId, providerId])
   @@index([userId])
}

model Session {
   id        String   @id @default(cuid())
   expiresAt DateTime
   token     String   @unique
   createdAt DateTime @default(now())
   updatedAt DateTime @updatedAt
   ipAddress String?
   userAgent String?
   userId    String
   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

   @@index([userId])
   @@index([token])
}

model Verification {
   id         String   @id @default(cuid())
   identifier String
   value      String
   expiresAt  DateTime
   createdAt  DateTime @default(now())
   updatedAt  DateTime @updatedAt
}

model TwoFactor {
   id          String   @id @default(cuid())
   userId      String   @unique
   secret      String
   backupCodes String   // better-auth stores as encrypted string
   createdAt   DateTime @default(now())
   updatedAt   DateTime @updatedAt
}

model DepositAddress {
  id              String   @id @default(cuid())
  userId          String
  address         String   @unique
  currency        String   // "ETH", "USDT", etc.
  derivationIndex Int      // HD wallet index
  createdAt       DateTime @default(now())
  user            User     @relation(fields: [userId], references: [id])

  @@unique([userId, currency])
  @@index([address])
}

model Deposit {
  id          String   @id @default(cuid())
  userId      String
  amount      Decimal
  currency    String
  txHash      String   @unique
  status      String   // "PENDING", "COMPLETED", "FAILED"
  fromAddress String
  toAddress   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([txHash])
}

model Withdrawal {
  id             String   @id @default(cuid())
  userId         String
  amount         Decimal
  currency       String
  toAddress      String
  txHash         String?
  idempotencyKey String?  @unique
  status         String   // "PENDING", "APPROVED", "REJECTED", "COMPLETED", "FAILED"
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  approvedAt     DateTime?
  approvedBy     String?  // Admin ID
  user           User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([status])
}

model UserFavorite {
  id        String   @id @default(cuid())
  userId    String
  eventId   String
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id])
  event     Event    @relation(fields: [eventId], references: [id])

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
}

model InstitutionalAccount {
   id          String   @id @default(cuid())
   userId      String   @unique
   name        String
   type        String   // e.g., "LIQUIDITY_PROVIDER", "MARKET_MAKER"
   maxOrderSize Float   @default(10000.0)
   maxDailyVolume Float @default(100000.0)
   dailyVolume Float    @default(0.0) // Current day's volume
   dailyVolumeDate DateTime? // Date when dailyVolume was last reset
   isActive    Boolean  @default(true)
   createdAt   DateTime @default(now())
   updatedAt   DateTime @updatedAt

   user        User     @relation(fields: [userId], references: [id])
   apiKeys     ApiKey[]

   @@index([userId])
}

model ApiKey {
  id          String   @id @default(cuid())
  accountId   String
  key         String   @unique
  secret      String   // hashed
  permissions String[] @default([]) // e.g., ["trade", "read", "admin"]
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  lastUsedAt  DateTime?

  account     InstitutionalAccount @relation(fields: [accountId], references: [id])

  @@index([key])
  @@index([accountId])
}
